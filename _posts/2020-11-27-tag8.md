---
title: "Tag 8"
date: 2020-11-27
---

<h1>Nachtrag zu Metadaten modellieren und Schnittstellen nutzen</h1>

<h2>Diskussion der Aufgabe zur Anreicherung</h2>
Zu dem Zeitpunkt wurde die Anreicherungsaufgabe in OpenRefine besprochen.
Darüber werde ich hier nicht berichten, aber möchte auf meinen [Eintrag verweisen(https://sakura-72.github.io/my-bain-blog/2020/11/26/anreicherung.html], in welcher ich ein kurzes Kommentar zu meine Fehler noch eingegeben habe.

<h2>Validierung von XML</h2>

* Wir exportieren das Gesamtergebnis als XML in ein neues Verzeichnis.

Wenn man ein sauberes XML machen möchte, muss man es mit einem XML-Schema abgleichen z.B. mit dem MARC21-Schema der Library of Congress. Man kann mit dem Schema von der Library of Congress nicht unbedingt die Inhalte verifizieren, aber zumindest die Form. Die Validierung ist eine wichtige Grundlage.
Diese Validierung wird vom Dozent an dem Beispiel der XML Datei mit den DOAJ-Daten aus Open Refine, welche wir zusammen exportiert haben.

* Für die Validierung können Sie das Programm `xmllint` verwenden, das unter Ubuntu vorinstalliert ist.
* Zum Abgleich gegen das offizielle Schema von MARC21 laden wir dieses (XSD) zunächst herunter.

Hier ein Beispiel, wie man mit disem Programm nutzen kann, um die Datei zu validieren:
```bash
wget https://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd
xmllint *.xml --noout --schema MARC21slim.xsd
```
Einerseits wird mit dem ersten Kommando anhand wget den Schema von der Library of Congress als Datei heruntergeladen. Hier ist es wichtig darauf zu achten, dass die Datei am gleichen Ort wie unsere DOAJ-Datei gespeichert wird. Hierfür hat Her Lohmeier den Ordner Download aufgewählt und somit diesen Befehl in der Shell eingegeben:
```bash
cd Downloads
```
Dann den zweiten oberen Befehl eingegeben, wobei hier statt *"*.xml"* den DOAJ-Dateiname eigegeben wird. Damit läuft die Validierung nur über die XML-Datei, welche wir auswählen, und nicht über alle XML-Dateaien. Den *--noout*-Befehl ist dafür da, dass den Inhalt der Datei nicht in der Shell ausgegeben wird (wir wollen ja nur eine Validierung). Zum Schluss den Befehl *--schema* und darauf folgend den Dateiname des Library of Congress Schemas, welches wir heruntergeladen haben.
```bash
xmllint *.xml --noout --schema MARC21slim.xsd
```
Schade! Es kommen einige Fehler, somit haben wir mit der DOAJ-Datei kein valides XML erzeugt. Das heisst, dass wir jetzt nach dem Fehler in einem Editor suchen müssen. Es scheint, dass den Feld 260 b nicht geschlossen worden ist: es fehlt den schliessenden Subfield *</subfeld>*. 
>Immerhin hat es den Vorteil, dass es uns aufzeigt, dass die Valisierung eine sinnvolle Sache ist. :)

!!! Da ein Bild wäre schön @Almira!!! :)

<h3> Exkurs: XML-Deklaration </h3>
Eine XML-Deklaration (wie eigentlich auch jede Deklaration, wie z.B. in einem XML-File) dient dazu, einen Programm den Format unsere Datei mitzuteilen. In diesem Fall, dass es sich bei einer Datei, um XML handelt. Dafür wird am Anfang der Datei wie folgt deklariert:
  ```
  <?xml version="1.0" encoding="utf-8" standalone="yes"?>
  ```
* Hier handelt es sich um einer XML-Datei der Version 1.0. mit der Zeichencodierung im Standard Unicode. 
* Auch entählt die Datei eine Dokumenttypdefinition (DTD). Das ist so in etwa ein Metadaten-Schema, welches aber nicht separat sondern im Dokument liegt und Auskunft über die Form der Datei gibt. Dies wird nach dem Element *standalone* definiert: entweder mit dem Wert *yes (in der Datei enthalten), no (es gibt ein Schema, aber liegt ausserhalb der Datei) oder (leer/weg)gelassen (heisst, das kein Schema beigelegt ist und die Datei an dem XML-Standard orientiert).

Was man sich merken sollte:
* Die Versionangabe ist pflicht, die Encoding-Angaben gehörten zur guten Praxis. Das leztes Element wird allerginds selten gebraucht.
* die Reihenfolge der Elemente einer Deklaration ist festgelegt.


  <h2>Weitere Tools zur Metadatentransformation</h2>
<h3> Zur Motivation </h3>

>Wir dürfen gerne das Interviews mit Kirsten Jeude anschauen, fall wir wissen wollen, wie das in der Praxis ist und auch wenn wir beruflich eventuell mit Metadaten arbeiten möchten.

Metadaten-Management in der Praxis, hier beim Leibniz-Informationszentrum Wirtschaft (ZBW) in Hamburg:
* Infoseite: <https://www.zbw.eu/de/ueber-uns/arbeitsschwerpunkte/metadaten/>
* Videointerview mit Kirsten Jeude: <https://www.youtube.com/watch?v=YwbRTDvt_sA>

<h3> Vergleich mit anderen Tools </h3>

* Merkmale von OpenRefine:
    * grafische Oberfläche: Transformationsergebnisse werden direkt sichtbar
    * Skriptsprachen (GREL, Jython, Clojure) für komplexe Transformationen
    * Schwerpunkt auf Datenanreicherung (Reconciliation)
* Alternative Software:
    * [Catmandu](https://librecat.org) (Perl)
    * [Metafacture](https://github.com/metafacture/metafacture-core) (Java)
    * [MarcEdit](https://marcedit.reeset.net) (für MARC21)
* Siehe auch: Prof. Magnus Pfeffer (2016): Open Source Software zur Verarbeitung und Analyse von Metadaten. Präsentation auf dem 6. Bibliothekskongress. <http://nbn-resolving.de/urn/resolver.pl?urn:nbn:de:0290-opus4-24490>

Note:
* Generell gilt, dass die passende Software anhand des Anwendungsfalls gewählt werden sollte.
* In der Praxis wird oft die Software verwendet, die schon gut beherrscht wird. Das macht es manchmal sehr umständlich.




  <h2>Nutzung von JSON-APIs>/h2>
  
  <h2>Metadatenstandard LIDO>/h2>
  
<h1>Suchmaschinen und Discovery-Systeme 1/2 </h1>

  <h2>Installation und Konfiguration von VuFind</h2>

  <h2>Funktion von Suchmaschinen am Beispiel von Solr</h2>
    
<h1>Aufgaben</h1>
